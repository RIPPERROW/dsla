{
  "details": "StakeRegistry is a contract to register the staking activity of the platform, along with controlling certain admin privileged parameters",
  "events": {
    "StakingParametersModified(uint256,uint256,uint256,uint256,uint256)": {
      "details": "event to log modifications on the staking parameters",
      "params": {
        "DSLAburnRate": "1. (DSLAburnRate/1000)% of DSLA to be burned after a reward/compensation is paid",
        "dslaDepositByPeriod": "2. DSLA deposit by period to create SLA",
        "dslaPlatformReward": "3. DSLA rewarded to Stacktical team",
        "dslaUserReward": "4. DSLA rewarded to user calling the period verification",
        "dslaBurnedByVerification": "5. DSLA burned after every period verification"
      }
    },
    "VerificationRewardDistributed(address,address,uint256,uint256,uint256)": {
      "details": "event to log a verifiation reward distributed",
      "params": {
        "sla": "1. The address of the created service level agreement contract",
        "requester": "2. -",
        "userReward": "3. -",
        "platformReward": "4. -",
        "burnedDSLA": "5. -"
      }
    }
  },
  "kind": "dev",
  "methods": {
    "addAllowedTokens(address)": {
      "details": "add a token to ve allowed for staking",
      "params": { "_tokenAddress": "1. address of the new allowed token" }
    },
    "constructor": { "params": { "_dslaTokenAddress": "1. DSLA Token" } },
    "createDToken(string,string)": {
      "details": "to create dTokens for staking",
      "params": { "_name": "1. token name", "_symbol": "2. token symbol" }
    },
    "getActivePool(address)": {
      "details": "returns the active pools owned by a user.",
      "params": { "_slaOwner": "1. owner of the active pool" },
      "returns": {
        "_0": "ActivePool[], array of structs: {SLAAddress,stake,assetName}"
      }
    },
    "owner()": { "details": "Returns the address of the current owner." },
    "registerStakedSla(address)": {
      "details": "register the sending SLA contract as staked by _owner",
      "params": { "_owner": "1. SLA contract to stake" }
    },
    "renounceOwnership()": {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "setSLARegistry()": {
      "details": "sets the SLARegistry contract address and can only be called once"
    },
    "slaWasStakedByUser(address,address)": {
      "details": "public view function that returns true if the _owner has staked on _sla",
      "params": { "_user": "1. address to check", "_sla": "2. sla to check" },
      "returns": { "_0": "bool, true if _sla was staked by _user" }
    },
    "transferOwnership(address)": {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    }
  },
  "stateVariables": {
    "_DSLAburnRate": {
      "details": "corresponds to the burn rate of DSLA tokens, but divided by 1000 i.e burn percentage = DSLAburnRate/1000 %"
    },
    "_dslaBurnedByVerification": {
      "details": "DSLA burned after every period verification"
    },
    "_dslaDepositByPeriod": {
      "details": "DSLA deposit by period to create SLA"
    },
    "_dslaPlatformReward": { "details": "DSLA rewarded to Stacktical team" },
    "_dslaUserReward": {
      "details": "DSLA rewarded to user calling the period verification"
    },
    "allowedTokens": {
      "details": "array with the allowed tokens addresses of the StakeRegistry"
    },
    "slaLockedValue": {
      "details": "(ownerAddress => slaAddress => LockedValue) stores the locked value by the staker"
    },
    "userStakedSlas": {
      "details": "(userAddress => SLA[]) with user staked SLAs to get tokenPool"
    }
  },
  "title": "StakeRegistry",
  "version": 1
}
