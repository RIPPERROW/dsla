{
  "kind": "dev",
  "methods": {
    "_claimCompensation(address)": {
      "details": "claim user compensation. Transfers both the compensation and the user remaining stake.",
      "params": {
        "_tokenAddress": "1. address of the token to claim compensation"
      }
    },
    "addAllowedTokens(address)": {
      "details": "add a token to ve allowed for staking",
      "params": { "_tokenAddress": "1. address of the new allowed token" }
    },
    "constructor": {
      "params": { "_stakeRegistry": "1. address of the base token" }
    },
    "getAllowedTokensLength()": {
      "details": "use this function to evaluate the length of the allowed tokens length",
      "returns": { "_0": "allowedTokens.length" }
    },
    "getStakeholdersPositions(address)": {
      "details": "gets the positions of stake both for provider and for users",
      "params": { "_tokenAddress": "1. token address to get the positions" },
      "returns": {
        "providerStake": "position of the provider (owner) of the SLA contract",
        "usersStake": "position of the user of the SLA contract"
      }
    },
    "isAllowedToken(address)": {
      "details": "checks in the allowedTokens array if there's a token with _tokenAddress value",
      "params": { "_tokenAddress": "1. token address to check exixtence" },
      "returns": {
        "_0": "true if _tokenAddress exists in the allowedTokens array"
      }
    },
    "isStaker(address)": {
      "details": "returns true if the _staker address is registered as staker",
      "params": { "_staker": "1. staker address" },
      "returns": { "_0": "true if address is staker" }
    },
    "owner()": { "details": "Returns the address of the current owner." },
    "renounceOwnership()": {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "transferOwnership(address)": {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    }
  },
  "stateVariables": {
    "DSLAburnRate": {
      "details": "corresponds to the burn rate of DSLA tokens, but divided by 1000 i.e burn percentage = burnRate/1000 %"
    },
    "allowedTokens": {
      "details": "array with the allowed tokens addresses for the current SLA"
    },
    "dslaTokenAddress": { "details": "DSLA token address to burn fees" },
    "minimumDSLAStakedTier1": {
      "details": "minimum deposit for Tier 1 staking"
    },
    "minimumDSLAStakedTier2": {
      "details": "minimum deposit for Tier 2 staking"
    },
    "minimumDSLAStakedTier3": {
      "details": "minimum deposit for Tier 3 staking"
    },
    "periodRegistry": { "details": "SLARegistry contract" },
    "periodType": {
      "details": "PeriodRegistry period type of the SLA contract"
    },
    "providerPeriodsRewards": {
      "details": "(periodId=>tokenAddress=>uint256) provider compensation per period and per token"
    },
    "slaPeriodsLength": {
      "details": "length of the _periodIds array, to state effective APY"
    },
    "stakeHoldersPositions": {
      "details": "(tokenAddress=>stakerAddress=>uint256) staker position to represent his proportion staked"
    },
    "stakeRegistry": { "details": "StakeRegistry contract" },
    "stakers": { "details": "address[] of the stakers of the SLA contract" },
    "tokenPools": {
      "details": "(tokenAddress=>uint256) total pooled token balance"
    },
    "usersCompensationPools": {
      "details": "(tokenAddress=>uint256) users available compensation per token"
    },
    "usersTotalPositions": {
      "details": "(tokenAddress=>uint256) used to keep track of the stakes of the users, to calculate proportion of compensation pool"
    },
    "whitelist": {
      "details": "(userAddress=bool) to declare whitelisted addresses"
    },
    "whitelisted": {
      "details": "boolean to declare if contract is whitelisted"
    },
    "yearlyPeriods": {
      "details": "PeriodRegistry defined amount of periods over a year"
    }
  },
  "version": 1
}
